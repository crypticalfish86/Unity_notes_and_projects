COLLIDERS, RIGID BODIES AND TRIGGERS

Collider: A component which detects when two colliders overlap

Rigid body: A component which determines that this object has
"mass" or "substance" and physics should be applied to it

First things first we need to add a "rigid body" to the player
component

Next we need to add a "collider" component to both
the player car and object to crash into we should be adding a 
2D collider of the same shape the image is


If we want the object the player crashes into to move/bounce around we need to also add a "rigid body" as a component to 
that object too.

There is a third kind of collision object called a "trigger" 
which allows an object to phase through it as if it was just an 
image however a trigger will "log" when an object has 
overlapped with it and can have a script written to trigger 
some sort of event. A trigger is created by adding a collider 
to an object and then in the collider component simply checking 
the "Is Trigger" box.

A trigger box can be a very good invisible object which is
used to determine when the player has "entered an area" or
triggered some sort of invisible trap


We can also change the collision detection on a rigid body 
between discrete  and continious. discrete uses less processing 
power however at high speeds has the tendency to phase through 
objects, contious has less of a chance to do this however it 
uses more processing power, so use one or the other based on 
the game/object.

ON_COLLISION_ENTER_2D()

    OnCollisionEnter2D is a method that executes
    when the object this script is attached to
    collides with something else.

    It looks like so:

        public void OnCollisionEnter2D(Collision2D other) {
            //execute code in this block
        }

    other represents information about the object that 
    this object has bumped into and allows you to determine
    what type of object you've bumped into and if any different
    blocks of code will execute based on the type of object
    that has collided with another object

ON_TRIGGER_ENTER_2D()

   OnTriggerEnter2D is a method that executes 
    when the object this script is attached to
    overlaps with a "trigger" object.

    It looks like so:
        public void OnTriggerEnter2D(Collision2D other){
            //execute code in this block
        }

    
    other represents information about the object that 
    this object has ran over the trigger into and allows you to determine what type of object you've bumped into and if any different blocks of code will execute based on the type of object that has collided with another object

IMPORTING ASSETS

You can actually just directly import PNG files into unity
to act as 2D sprites, You will definitley learn more about this
another time as well as how to create your own assets, but
for now we will simply use pre-provided assets

UNITY UNITS

Unity has "units" of measurement for sizes/distances
the units don't actually mean anything, they can represent
metres, inches, kilometers etc. However they're a consistent
measurement of distance that we relatively scale all of our
models to. It's good in your project to define how big
one "unity unit" is in actual measurements for objects
on the same plane as each other

New assets imported to unity default to 100 pixels per
unity unit (as in 1 unity unit is equal to a 100x100 pixel 
image). We can change this in the settings for our assets
if we want to change how many pixels fit in one unit, this
should ideally be consistent across all assets for a consistent
art style in a project.

When creating reference objects its good practice to scale 
everything to the size you want by editing the assets "pixel 
per unit". If you want different objects to be different sizes 
you can then using the scaling tool to edit that but a standard 
size for all components is useful

We can switch a component to "snap" to unity unit mode (meaning 
when you move the component it will always move directly along 
unity units) by clicking on the object, switching to "global" 
and then checking the "snap" tool on the same toolbar as the 
global option


UNITY HIERACHY

A good practice is to make reference objects and put them as 
children under a global "ReferenceGameObjects" and set that 
object to the position (0,0,0) so you always know where the 
centre of the world is.


FOLLOWING CAMERA

For a simple camera that follows the player through the game 
we'd need to keep the cameras central position at the centre
of the player object, to do this we need to update the cameras
transform.position value every frame to the centre of the
player object. 

To do this we will somehow in a script on the camera need
to access the transform.position of the player object. For
this we need to create a reference to the player object which
can be by creating a [SerializeField] in the C# script and
in unity when it now shows up under the script, set it to 
the player object you want the camera to follow.

Now that we have a reference to the player object in our script
we can set the transform.position of the camera to our player
object. (Note in 2D especially we have to give our camera
a small offset in the Z direction because otherwise
it will go directly on the car and you wont be able to see 
anything)

In order to ensure our script knows what we're talking about
we need to add a distance via a new "vector" which is the
type of object transform.position is. It would be done
like follows:

transform.position = playerObject.transform.position + new Vector3 (0, 0, -10);

transform.position in unity is an object called Vector3, we are 
just adding an extra vector to it in a way it understands, you 
will need to study objects like this in unity when they come 
up, or look up online how to do it.


CINEMACHINE FOLLOW CAMERA

Theres a more complex type of follow camera called 
"cinemachine" which allows us to use various features not 
available with a simple follow camera.

Cinemachine is a powerful package that lets us manage multiple 
cameras at once in our scene as well as easily creating rules 
for our cameras.

Essentially there will always be one "Main camera" that 
represents what the user actually sees on the screen (meaning 
whats on the actual computer screen). But there will also be 
multiple "virtual cameras" with different behaviours that the 
cinimachine engine will switch to in order to represent 
different behaviours based on events in the game. These virtual 
cameras are then projected onto the main camera for the user to 
experience (for example when the player goes really fast we 
might zoom out or when they're really slow the camera might 
zoom in).

We are essentially doing cinematography for our game. This is 
also a very powerful tool to make cutscenes in games. 
Cinemachine is a package you need to import in unity which if 
you don't know how to do we will briefly talk about in the next 
section.

To initiate the cinemachine logic engine add a virtual camera to the hierachy


IMPORTING PACKAGES

Go to "Window" on the toolbar and go to "Package Manager", 
switch "packages" to include the Unity Registry and install the 
package you want from that list. The package you want depending
on its functions and features will now appear in components or 
when right clicking on the hierachy.

TAGS

Tags in unity are labels we give to objects that we can use to 
determine what "type of object" that object is, for example the 
player object gets the "player" tag or a delivery box gets the 
"delivery" tag, that tag is then available in our code as a 
string which we can then use to trigger conditional logic on 
what happens when an object of this type interacts with an 
object of another type.

The object tag is available via:  Object.tag;

HOW TO DESTROY OBJECTS

Sometimes we want an object to be destroyed/despawned from the world. We do this by calling Destroy().

Destroy() takes two arguments, the first argument is
the object you want to destroy through the format Object.
gameObject. And the second argument is and optional argument of 
how long of a delay in seconds before destroying the object, if 
this isn't provided the object will be destroyed immediatley.

HOW TO USE GetComponent

Objects can have a multitude of components, we can access a specific component and it's properties to view/change using 
GetComponent<Component> Where "Component" is the
component of the object this script is attached to.

e.g. 

SpriteRenderer sprite = GetComponent<SpriteRenderer>();

If the object this script is attached to has a component
called SpriteRenderer, then it will now be stored
in sprite and we can access its properties.